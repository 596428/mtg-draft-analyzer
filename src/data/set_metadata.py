"""Set metadata loader for mechanic and theme information."""

import logging
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

import yaml

logger = logging.getLogger(__name__)


@dataclass
class Mechanic:
    """Represents a set mechanic."""

    name: str
    description: str
    strategy_tip: str = ""


@dataclass
class SetMetadata:
    """Metadata for a specific MTG set."""

    code: str
    name: str
    release_date: str = ""
    mechanics: list[Mechanic] = field(default_factory=list)
    themes: list[str] = field(default_factory=list)
    speed_context: str = ""
    draft_tips: list[str] = field(default_factory=list)

    def get_mechanics_summary(self) -> str:
        """
        Generate a formatted summary of set mechanics for LLM prompts.

        Only outputs mechanics information. Other fields (themes, speed_context,
        draft_tips) are intentionally excluded as they either:
        - Duplicate data already calculated from 17lands (speed_context)
        - Should be generated by the LLM, not hardcoded (draft_tips)

        Returns:
            Markdown-formatted string describing set mechanics
        """
        if not self.mechanics:
            return ""

        lines = [f"## {self.name} ({self.code}) μ„ΈνΈ λ©”μ»¤λ‹‰"]

        for mech in self.mechanics:
            lines.append(f"- **{mech.name}**: {mech.description}")
            if mech.strategy_tip:
                lines.append(f"  - π’΅ μ „λµ: {mech.strategy_tip}")

        return "\n".join(lines)


class SetMetadataLoader:
    """Singleton loader for set metadata configuration."""

    _instance: Optional["SetMetadataLoader"] = None
    _metadata: dict[str, SetMetadata] = {}

    def __new__(cls, config_path: str = "config/set_mechanics.yaml"):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._load_config(config_path)
        return cls._instance

    def _load_config(self, config_path: str) -> None:
        """Load set metadata from YAML config file."""
        path = Path(config_path)

        if not path.exists():
            logger.warning(f"Set mechanics config not found: {config_path}")
            return

        try:
            with open(path, "r", encoding="utf-8") as f:
                config = yaml.safe_load(f)

            if not config:
                logger.warning("Empty set mechanics config")
                return

            for code, data in config.items():
                if not isinstance(data, dict):
                    continue

                # Parse mechanics
                mechanics = []
                for mech_data in data.get("mechanics", []):
                    if isinstance(mech_data, dict):
                        mechanics.append(
                            Mechanic(
                                name=mech_data.get("name", ""),
                                description=mech_data.get("description", ""),
                                strategy_tip=mech_data.get("strategy_tip", ""),
                            )
                        )

                self._metadata[code] = SetMetadata(
                    code=code,
                    name=data.get("name", code),
                    release_date=data.get("release_date", ""),
                    mechanics=mechanics,
                    themes=data.get("themes", []),
                    speed_context=data.get("speed_context", ""),
                    draft_tips=data.get("draft_tips", []),
                )

            logger.info(f"Loaded metadata for {len(self._metadata)} sets")

        except yaml.YAMLError as e:
            logger.error(f"Failed to parse set mechanics YAML: {e}")
        except Exception as e:
            logger.error(f"Failed to load set mechanics: {e}")

    def get_set_metadata(self, expansion: str) -> Optional[SetMetadata]:
        """
        Get metadata for a specific set.

        Args:
            expansion: Set code (e.g., "ECL", "DSK")

        Returns:
            SetMetadata if found, None otherwise
        """
        return self._metadata.get(expansion.upper())

    def get_mechanics_summary(self, expansion: str) -> str:
        """
        Get formatted mechanics summary for a set.

        Args:
            expansion: Set code

        Returns:
            Formatted string for LLM prompts, empty if set not found
        """
        metadata = self.get_set_metadata(expansion)
        if metadata:
            return metadata.get_mechanics_summary()
        return ""

    def has_metadata(self, expansion: str) -> bool:
        """Check if metadata exists for a set."""
        return expansion.upper() in self._metadata

    @classmethod
    def reset(cls) -> None:
        """Reset singleton instance (mainly for testing)."""
        cls._instance = None
        cls._metadata = {}


# Convenience functions
def get_set_mechanics(expansion: str) -> str:
    """
    Get set mechanics summary for LLM prompts.

    Args:
        expansion: Set code (e.g., "ECL", "DSK")

    Returns:
        Formatted mechanics summary, empty string if not found
    """
    loader = SetMetadataLoader()
    return loader.get_mechanics_summary(expansion)


def get_set_metadata(expansion: str) -> Optional[SetMetadata]:
    """
    Get full set metadata.

    Args:
        expansion: Set code

    Returns:
        SetMetadata if found, None otherwise
    """
    loader = SetMetadataLoader()
    return loader.get_set_metadata(expansion)
